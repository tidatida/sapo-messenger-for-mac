%{
//
//  NSString+URLScannerAdditions.lm
//  Lilypad
//
//	Copyright (C) 2006-2007 PT.COM,  All rights reserved.
//	Author: Joao Pavao <jppavao@criticalsoftware.com>
//
//	For more information on licensing, read the README file.
//	Para mais informações sobre o licenciamento, leia o ficheiro README.
//
	
#import "NSString+URLScannerAdditions.h"


// Redefined prototype for yylex() so that we can have custom parameter and return types
#define YY_DECL NSRange yylex( NSString **oNormalizedURLStr )

// The following is to be used inside rule actions
#define FOUND_URL_AT_POSITION(location_var, leng, url_str, prefix_for_normalizing_url)	\
	{																					\
		if (oNormalizedURLStr) {														\
			*oNormalizedURLStr = [NSString stringWithFormat:@"%@%s",					\
				(prefix_for_normalizing_url ? prefix_for_normalizing_url : @""),		\
				url_str];																\
		}																				\
		return NSMakeRange(location_var, leng);											\
	}

/*
 * CanHandleGenericURL() expects a pointer to a URL string (and its str length) and checks
 * whether there's some application installed in the system that can handle it.
 */
static BOOL CanHandleGenericURL (const char *text, unsigned int leng)
{
	BOOL urlCanBeHandled = NO;
	
	NSString *urlStr = [[NSString alloc] initWithBytes:text length:leng encoding:NSUTF8StringEncoding];
	NSURL *url = [NSURL URLWithString:urlStr];
	[urlStr release];
	
	/* Is this a URL scheme that can be handled by some app in the system? */
	if (url) {
		CFURLRef appURL = NULL;
		OSStatus status = LSGetApplicationForURL((CFURLRef)url, kLSRolesAll, NULL, &appURL);
		
		if (appURL != NULL) CFRelease(appURL);
		
		urlCanBeHandled = (status == noErr && appURL != NULL);
	}
	return urlCanBeHandled;
}


%}


%option noyywrap
%option nounput
%option prefix="url_scanner_yy"


SAFE				[-_$.+]
EXTRA				[!*'(),]
NATIONAL			[{}|\\^~\[\]`]
PUNCTUATION			[<>#%"]
RESERVED			[;/?:@&=]
HEX					[a-fA-F0-9]
ESCAPE				"%"{HEX}{HEX}
UNRESERVED			([[:alnum:]]|{SAFE}|{EXTRA})
UCHAR				({UNRESERVED}|{ESCAPE})
XCHAR				({UNRESERVED}|{ESCAPE}|{RESERVED})

TOPDOMAINLABEL		([[:alpha:]]|([[:alpha:]][-[:alnum:]]*[[:alnum:]]))
DOMAINLABEL			([[:alnum:]]|([[:alnum:]][-[:alnum:]]*[[:alnum:]]))
HOSTNAME			({DOMAINLABEL}".")*{TOPDOMAINLABEL}

IPDIGITS			[[:digit:]]{1,3}
HOSTNUMBER			({IPDIGITS}"."){3}{IPDIGITS}

HOST				{HOSTNAME}|{HOSTNUMBER}

URLSCHEME			([[:alpha:]]|([[:alpha:]][-[:alnum:]]*[[:alnum:]]))

USERPASSCHAR		({UCHAR}|[;?&=])
USERPASS			{USERPASSCHAR}+(":"{USERPASSCHAR}+)?

HOSTPORT			{HOST}(":"[[:digit:]]+)?

LOGIN				({USERPASS}"@")?{HOSTPORT}

FPATHCHAR			{UCHAR}|[?:@&=]
FPATHCOMPONENT		"/"{FPATHCHAR}*

HPATHCHAR			{UCHAR}|[;:@&=~]
HPATHCOMPONENT		"/"{HPATHCHAR}*
HQUERY				"?"({HPATHCHAR}|"/")*
HANCHOR				"#"{HPATHCHAR}+

MAILACCOUNTCHAR		[-_.+[:alnum:]]


XUNRESERVED			[-_.~[:alnum:]]
XQCHAR				{XUNRESERVED}|{ESCAPE}
XPCHAR				{XUNRESERVED}|{ESCAPE}|[!$&'()*+,;=:@]

XRESALLOW			[!"$&'()*+,:;<=>\[\\\]^`{|}]
XRESID				({XUNRESERVED}|{ESCAPE}|{XRESALLOW})*

XNODEALLOW			[!$()*+,;=\[\\\]^`{|}]
XNODEID				({XUNRESERVED}|{ESCAPE}|{XNODEALLOW})*

JID					({XNODEID}"@")?{HOST}("/"{XRESID})?

XMPPAUTH			"//"{XNODEID}"@"{HOST}("/"{JID})?
XMPPQUERY			"?"{XQCHAR}*(";"{XQCHAR}*"="{XQCHAR}*)*
XMPPFRAGMENT		"#"({XPCHAR}|"/"|"?")*

%%

	unsigned int current_location = 0;

"<"("ftp://"|"file://"|"http://"|"https://"|"feed://"|"mailto:"|"xmpp:"|"telnet://").*">"		{
									/* Take the angle brackets out of the resulting URL */
									FOUND_URL_AT_POSITION(current_location + 1, yyleng - 2, yytext + 1, nil);
								}

{URLSCHEME}":"[[:graph:]]+		{
									if (CanHandleGenericURL(yytext, yyleng)) {
										FOUND_URL_AT_POSITION(current_location, yyleng, yytext, nil);
									} else {
										/* Let some other rule take care of this input as if it was regular text */
										REJECT;
									}
								}

"<"{URLSCHEME}":".+">"			{
									if (CanHandleGenericURL(yytext + 1, yyleng - 2)) {
										/* Take the angle brackets out of the resulting URL */
										FOUND_URL_AT_POSITION(current_location + 1, yyleng - 2, yytext + 1, nil);
									} else {
										/* Let some other rule take care of this input as if it was regular text */
										REJECT;
									}
								}

"ftp://"{LOGIN}{FPATHCOMPONENT}*(";type="[AIDaid])?							|
"file://"{HOST}?{FPATHCOMPONENT}*											|
("http://"|"https://"|"feed://"){LOGIN}{HPATHCOMPONENT}*{HQUERY}?{HANCHOR}?	|
"mailto:"{MAILACCOUNTCHAR}+"@"{HOST}{HQUERY}?								|
"xmpp:"({XMPPAUTH}|{JID}){XMPPQUERY}?{XMPPFRAGMENT}?						|
"telnet://"{LOGIN}"/"?														FOUND_URL_AT_POSITION(current_location, yyleng, yytext, nil);

	/* The patterns that follow represent commonly used forms of incomplete URLs */

"www"("."{HOSTNAME})?											FOUND_URL_AT_POSITION(current_location, yyleng, yytext, @"http://");
{MAILACCOUNTCHAR}+"@"{HOST}										FOUND_URL_AT_POSITION(current_location, yyleng, yytext, @"mailto:");

[[:alnum:]]+							|
.|\n									current_location += yyleng;

<<EOF>>									return NSMakeRange(NSNotFound, 0);

%%


@implementation NSString (URLScannerAdditions)


- (NSRange)rangeOfNextURLInRange:(NSRange)searchRange normalizedURLString:(NSString **)oNormalizedURLStr
{
	YY_BUFFER_STATE		lex_buffer;
	NSRange				foundRange;
	const char *		cString = (const char *)[[self dataUsingEncoding:NSISOLatin1StringEncoding allowLossyConversion:YES] bytes];
	
	lex_buffer = yy_scan_bytes(cString + searchRange.location, searchRange.length);
	foundRange = yylex(oNormalizedURLStr);
	yy_delete_buffer(lex_buffer);
	
	if (foundRange.location != NSNotFound) {
		// Make the location in the found range be relative to the start of the original NSString
		foundRange.location += searchRange.location;
	}
	
	return foundRange;
}


- (NSArray *)allParsedURLDescriptions
{
	NSMutableArray *listOfURLDescritions = [NSMutableArray array];
	
	NSString	*normalizedURLString = nil;
	unsigned int currentLocation = 0;
	unsigned int remainingLength = [self length];
	
	NSRange		 searchRange = NSMakeRange(currentLocation, remainingLength);
	NSRange		 nextURLRange = [self rangeOfNextURLInRange:searchRange normalizedURLString:&normalizedURLString];
	
	while (nextURLRange.location != NSNotFound) {
		
		// Build the URL description dictionary
		NSDictionary *theURLDict = [NSDictionary dictionaryWithObjectsAndKeys:
									[self substringWithRange:nextURLRange],		@"OriginalURLText",
									[NSURL URLWithString:normalizedURLString],	@"URL",
									NSStringFromRange(nextURLRange),			@"RangeInString", nil];
		
		[listOfURLDescritions addObject:theURLDict];
		
		
		currentLocation = NSMaxRange(nextURLRange);
		remainingLength = [self length] - currentLocation;
		
		searchRange = NSMakeRange(currentLocation, remainingLength);
		
		nextURLRange = [self rangeOfNextURLInRange:searchRange normalizedURLString:&normalizedURLString];
	}
	
	return listOfURLDescritions;
}


@end
